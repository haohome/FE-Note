<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Document</title>
</head>
<body>
    <div style="width:100px; height:3000px"></div>
    <div id="div1" style="width:50px; height:50px; background:red; position:absolute; top:1000px"></div>
    <div id="div2" style="width:50px; height:50px; background:blue; position:absolute; top:2500px"></div>
</body>
<script type="text/javascript">
    // 这里值得注意的是 : 目标对象呈现在客户区域时，会随着滚动而不断的弹出窗口。
    // 因此我们需要在弹出第一个窗口后取消对该区域的监测，
    // 我们可以用一个数组来收集需要监测的对象，触发后取消监测。


    // 返回浏览器的可视区域位置
    function getClient(){
        var l, t, w, h;
        l = document.documentElement.scrollLeft || document.body.scrollLeft;
        t = document.documentElement.scrollTop || document.body.scrollTop;
        w = document.documentElement.clientWidth;
        h = document.documentElement.clientHeight;
        return { left: l, top: t, width: w, height: h };
    }

    // 返回待加载资源位置
    function getSubClient(p){
        var l = 0, t = 0, w, h;
        w = p.offsetWidth;
        h = p.offsetHeight;
        while(p.offsetParent){
            l += p.offsetLeft;
            t += p.offsetTop;
            p = p.offsetParent;
        }
        return { left: l, top: t, width: w, height: h };
    }

    // 其中 函数getClient()返回浏览器客户区区域信息，getSubClient()返回目标模块区域信息。
    // 此时确定目标模块是否出现在客户区实际上是确定如上两个矩形是否相交。

    // 判断两个矩形是否相交,返回一个布尔值
    function intens(rec1, rec2){
        var lc1, lc2, tc1, tc2, w1, h1;
        lc1 = rec1.left + rec1.width / 2;
        lc2 = rec2.left + rec2.width / 2;
        tc1 = rec1.top + rec1.height / 2 ;
        tc2 = rec2.top + rec2.height / 2 ;
        w1 = (rec1.width + rec2.width) / 2 ;
        h1 = (rec1.height + rec2.height) / 2;
        return Math.abs(lc1 - lc2) < w1 && Math.abs(tc1 - tc2) < h1 ;
    }

    // 比较某个子区域是否呈现在浏览器区域
    function jiance(arr, prec1, callback){
        var prec2;
        // 循环遍历监测队列中的元素
        for (var i = arr.length - 1; i >= 0; i--) {
            if (arr[i]) {
                // 获取元素 位置
                prec2 = getSubClient(arr[i]);
                // 比较是否 交叉了，即元素是否出现在可视区域内了
                if (intens(prec1, prec2)) {
                    // 回调该元素，执行加载资源操作
                    callback( arr[ i ] );
                    // 该元素已执行加载，删除监测，下一次遍历就没有他了
                    delete arr[i];
                }
            }
        }
    }

    // 检测目标对象是否出现在客户区
    function autocheck(){
        var prec1 = getClient();
        jiance(arr, prec1, function( obj ){
            // 加载资源...
            alert(obj.innerHTML + "可以加载该资源了");
        })
    }


    // 子区域一
    var d1 = document.getElementById("div1");
    // 子区域二
    var d2 = document.getElementById("div2");

    // 通过数组将需要 按需加载的内容 集合存放，以添加监测
    var arr = [d1, d2];

    // onscroll 和 onresize 都会让 元素 出现，所以都要监测
    window.onscroll = function(){
        autocheck();
    }
    window.onresize = function(){
        autocheck();
    }
</script>
</html>